<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.example.demo.repository.ChecklistStartRepository">

  <!-- ──────────────────── 체크리스트 기본 정보 ──────────────────── -->

  <select id="getChecklistById" resultType="com.example.demo.vo.ChecklistForStart">
    SELECT
      id          AS id,
      CODE        AS code,
      title       AS title,
      DESCRIPTION AS description,
      reg_date    AS regDate,
      update_date AS updateDate
    FROM checklists
    WHERE id = #{checklistId}
  </select>

  <select id="getQuestionsByChecklistId" resultType="com.example.demo.vo.ChecklistQuestionForStart">
    SELECT
      id            AS id,
      checklist_id  AS checklistId,
      CODE          AS code,
      question_text AS questionText,
      help_text     AS helpText,
      response_type AS responseType,
      CAST(options_json AS CHAR) AS optionsJson,
      weight        AS weight,
      sort_order    AS sortOrder,
      domain_code   AS domainCode
    FROM checklist_questions
    WHERE checklist_id = #{checklistId}
    ORDER BY sort_order ASC, id ASC
  </select>

  <!-- ──────────────────── Run 조회 ──────────────────── -->

  <!-- DRAFT 상태의 가장 최근 run id 조회 -->
  <select id="getLatestDraftRunId" resultType="long">
    SELECT id
    FROM checklist_runs
    WHERE user_id      = #{userId}
      AND child_id     = #{childId}
      AND checklist_id = #{checklistId}
      AND `STATUS`     = 'DRAFT'
    ORDER BY id DESC
    LIMIT 1
  </select>

  <!-- DRAFT run 기본 정보 조회 (임시저장 선택 화면 표시용) -->
  <select id="getRunBasicInfo" resultType="map">
    SELECT
      r.id                                              AS runId,
      r.child_id                                        AS childId,
      ch.name                                           AS childName,
      cl.title                                          AS checklistTitle,
      DATE_FORMAT(r.update_date, '%Y-%m-%d %H:%i')     AS lastSavedAt,
      r.total_score                                     AS totalScore
    FROM checklist_runs r
    INNER JOIN children   ch ON ch.id = r.child_id
    INNER JOIN checklists cl ON cl.id = r.checklist_id
    WHERE r.id = #{runId}
    LIMIT 1
  </select>

  <!-- run이 속한 checklist_id (form 위변조 검증용) -->
  <select id="getChecklistIdByRunId" resultType="long">
    SELECT checklist_id
    FROM checklist_runs
    WHERE id = #{runId}
    LIMIT 1
  </select>

  <!-- run 소유권 확인 -->
  <select id="countRunOwnedByUser" resultType="int">
    SELECT COUNT(*)
    FROM checklist_runs
    WHERE id      = #{runId}
      AND user_id = #{userId}
  </select>

  <!-- run 상태 조회 -->
  <select id="getRunStatusByIdAndUserId" resultType="string">
    SELECT `STATUS`
    FROM checklist_runs
    WHERE id      = #{runId}
      AND user_id = #{userId}
    LIMIT 1
  </select>

  <!-- 아이가 없을 때 폴백용 첫 번째 자녀 id -->
  <select id="getFirstChildIdByUserId" resultType="long">
    SELECT id
    FROM children
    WHERE user_id = #{userId}
    ORDER BY id ASC
    LIMIT 1
  </select>

  <!-- ──────────────────── Run 생성 / 상태 변경 ──────────────────── -->

  <!-- 새 DRAFT run 생성 -->
  <insert id="createRun">
    INSERT INTO checklist_runs
      (checklist_id, child_id, user_id, `STATUS`, total_score, reg_date, update_date)
    VALUES
      (#{checklistId}, #{childId}, #{userId}, 'DRAFT', 0, NOW(), NOW())
  </insert>

  <!-- 직전 INSERT의 자동 생성 id (같은 커넥션/트랜잭션 내에서만 신뢰) -->
  <select id="getLastInsertId" resultType="long">
    SELECT LAST_INSERT_ID()
  </select>

  <!--
    DRAFT → SUBMITTED 전환.
    STATUS = 'DRAFT' 조건을 추가해 이미 SUBMITTED된 run을 재UPDATE하지 않도록 방어한다.
    affected rows = 0이면 이미 제출된 것으로 간주.
  -->
  <update id="submitRun">
    UPDATE checklist_runs
    SET
      `STATUS`       = 'SUBMITTED',
      total_score    = #{totalScore},
      submitted_date = NOW(),
      update_date    = NOW()
    WHERE id       = #{runId}
      AND `STATUS` = 'DRAFT'
  </update>

  <!--
    (userId, childId, checklistId) 기준 DRAFT 상태인 모든 run의 answers를 삭제한다.
    discardDraftRuns() 전에 호출해 FK 제약 위반을 방지한다.
  -->
  <delete id="deleteAnswersByDraftRuns">
    DELETE ca
    FROM checklist_answers ca
    INNER JOIN checklist_runs cr ON cr.id = ca.run_id
    WHERE cr.user_id      = #{userId}
      AND cr.child_id     = #{childId}
      AND cr.checklist_id = #{checklistId}
      AND cr.`STATUS`     = 'DRAFT'
  </delete>

  <!--
    (userId, childId, checklistId) 기준 모든 DRAFT run을 DISCARDED로 변경한다.
    이후 getLatestDraftRunId()는 해당 run들을 반환하지 않는다.
  -->
  <update id="discardDraftRuns">
    UPDATE checklist_runs
    SET
      `STATUS`    = 'DISCARDED',
      update_date = NOW()
    WHERE user_id      = #{userId}
      AND child_id     = #{childId}
      AND checklist_id = #{checklistId}
      AND `STATUS`     = 'DRAFT'
  </update>

  <!-- ──────────────────── 답변 UPSERT ──────────────────── -->

  <!--
    (run_id, question_id) UNIQUE 제약 필요:
      ALTER TABLE checklist_answers
        ADD UNIQUE KEY uq_answer_run_question (run_id, question_id);
    해당 제약이 없으면 ON DUPLICATE KEY UPDATE가 동작하지 않고 중복 INSERT됨.
  -->
  <insert id="upsertAnswer">
    INSERT INTO checklist_answers
      (run_id, question_id, answer_value, answer_text, score, reg_date, update_date)
    VALUES
      (#{runId}, #{questionId}, #{answerValue}, #{answerText}, #{score}, NOW(), NOW())
    ON DUPLICATE KEY UPDATE
      answer_value = VALUES(answer_value),
      answer_text  = VALUES(answer_text),
      score        = VALUES(score),
      update_date  = NOW()
  </insert>

  <!-- ──────────────────── 답변 조회 ──────────────────── -->

  <select id="getAnswersByRunId" resultType="com.example.demo.vo.AnswerForStart">
    SELECT
      run_id      AS runId,
      question_id AS questionId,
      answer_value AS answerValue,
      answer_text  AS answerText,
      score        AS score
    FROM checklist_answers
    WHERE run_id = #{runId}
  </select>

</mapper>
